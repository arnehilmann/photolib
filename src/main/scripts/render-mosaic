#!/usr/bin/env python
"""
Usage:
    render-mosaic --in=FILES...
                    [--distance=INT]
                    [--cheat=INT]...
                    [--nr-x=INT]...
                    [--outdir=DIR]
                    --tiles-dir=DIR TILES_DIRS...

Options:
    --distance=INT  minimum distance of repeated tile [default: 5]
    --cheat=INT...  percentage of "cheating" [default: 10]
    --nr-x=INT...   width of mosaic in tiles [default: 10]
    --outdir=DIR    where to store the mosaics [default: .]
"""
import glob
import logging
import os
import subprocess
import sys
import time
from docopt import docopt

TILES_SIZE = 240

arguments = docopt(__doc__)
print arguments

nr_xs = arguments["--nr-x"]
cheats = arguments["--cheat"]
distance = TILES_SIZE * int(arguments["--distance"])
libs = ["--library=%s" % l
        for subdir in arguments["TILES_DIRS"]
        for l in glob.glob(os.path.join(arguments["--tiles-dir"], subdir))]
outdir = arguments["--outdir"]

processes = []
for input in arguments["--in"]:
    size = subprocess.check_output(["metapixel-imagesize", input])
    width, height = size.split()
    for nr_x in nr_xs:
        nr_x = int(nr_x)
        print "nr x: %i" % nr_x
        scale = 1.0 * int(nr_x) * TILES_SIZE / int(width)

        input_basename = os.path.splitext(os.path.basename(input))[0]

        for cheat in cheats:
            cheat = int(cheat)
            print cheat
            output = os.path.join(outdir, "%s/%s.%02i.%02i.jpg" % (time.strftime("%Y-%m-%d"), input_basename, nr_x, cheat))

            out_dir = os.path.dirname(output)
            if out_dir and not os.path.exists(out_dir):
                os.makedirs(out_dir)

            cmd = ["metapixel", "--cheat=%s" % cheat, "--scale=%s" % scale,
                    "--width=%s" % TILES_SIZE, "--height=%s" % TILES_SIZE,
                    "--distance=%s" % distance, "--metric=subpixel"]
            cmd.extend(libs)
            cmd.extend(["--metapixel", input, output])
            logging.info("generating %s" % output)
            print "generating %s" % output
            logging.debug(cmd)
            process = subprocess.Popen(cmd)
            process.output = output
            processes.append(process)

still_running = 1
while still_running > 0:
    time.sleep(2)
    still_running = 0
    for process in processes:
        if process.poll() is None:
            still_running += 1
    print
    print "processes still running: %i / %i" % (still_running, len(processes))

exit_codes = []
for process in processes:
    print "%s: exit %i" % (process.output, process.returncode)
    exit_codes.append(process.returncode)

sys.exit(max(exit_codes))
